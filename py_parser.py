import argparseimport astimport osimport os.pathimport collectionsfrom nltk import pos_tagfrom git import Repoimport jsonimport gitimport csvparser = argparse.ArgumentParser(description='The script can:\n'+'1. For convenience, it is possible to clone repositories from different sources\n'+'2. Give statistics of the most frequent words by verbs or nouns (VB - verb , NN -noun)\n'+'3. Depending on the parameter, you can analyze frequently used function names or names of local variables of these functions\n'+'4. give statistics of frequently used words in the specified module\n'+'5. Output the result of the script in various formats.\n'+'All parameters are entered with a comma, if there is no paramiter, put a comma.\r\n'+'Enjoy!')parser.add_argument('repository', nargs = "?",type = bool,help='The link to the repository you want to clone')parser.add_argument('partofspeech', nargs = "?",const = str,help='The parts of the speech to be found.')parser.add_argument('codepart', nargs = "?",const = str,help='Any part of the code that needs to be analyzed (FUNCTION, VARIABLE')parser.add_argument('formatsave', nargs = "?",const = str,help='Format of data saving(csv,json)')args = parser.parse_args()def check_part_of_speech(wordcheck, part):    """    :param wordcheck: words that need to be check for part of the спечь    :param part:чать речи на которую требуется проверить слово    :return:    Verification of a word on a part speech    """    if  part is None:        raise PartSpeechError("Parameter part of speech is not specified")    return pos_tag([wordcheck])[0][1] == partdef add_values(somelist):    """    :param somelist:    :return:  [(1,2), (3,4)] -> [1, 2, 3, 4]    """    return sum([list(item) for item in somelist], [])class FindInListError(Exception):    passclass PartSpeechError(Exception):    passdef form_path_python_files(paths):    """    :param pathse: paths where we must find python files    :return: python files    """    filesnames = []    for path in paths:        for root, dirs, files in os.walk(path, topdown=False):            filesnames += [os.path.join(root, file) for file in files if file.endswith('.py')]    if len(filesnames) == 0:        raise FindInListError("The list is empty")    return filesnamesdef form_trees_ast(namessearch):    """    :param namessearch: name python files    :return: AST trees    Parse the source into an AST tree    """    asttrees = []    for filename in namessearch:        with open(filename, 'r', encoding='utf-8') as attempthandler:            main_file_content = attempthandler.read()        try:            tree = ast.parse(main_file_content)        except SyntaxError:            continue        asttrees.append(tree)    return asttreesdef serch_variables_names(asttrees, analyzepart):    """    :param asttrees: AST tree    :param analyzepart: variables in AST trees    :return:    select variables in trees    """    variables = []    for t in asttrees:        for node in ast.walk(t):            if isinstance(node, ast.FunctionDef):                for nodefunction in ast.walk(node):                    if isinstance(nodefunction, ast.Assign):                        for nodeassign in ast.walk(nodefunction):                            if isinstance(nodeassign, analyzepart) and not isinstance(nodeassign.ctx, ast.Load):                                variables.append(nodeassign.id)    return  variablesdef search_functions_in_trees(asttrees, functionclass):    """    :param asttrees: all trees    functionclass: class of objects to be found    :return: python module trees    select function module in trees function    """    functions = []    for t in asttrees:        for node in ast.walk(t):            if isinstance(node, functionclass):                functions.append(node.name.lower())    if len(functions) == 0:        raise FindInListError("The list is empty")    return functionsdef leave_only_not_special_functions(listmodules):    """    :param listmodules: python modules    :return: sort list without python magic function names    The function selects not magic function names in the list    """    return [function for function in listmodules if not (function.startswith('__') and function.endswith('__'))]def find_not_special_functions_in_tree(asttrees):    sortedlist = leave_only_not_special_functions(asttrees)    if len(sortedlist) == 0:        raise FindInListError("The list is empty")    return sortedlistdef split_name_in_part_of_speech(parts):    """    :param functionsnames:    :return: lists words    split function name to words    """    splitdwords = []    for word in parts:        splitsname = word.split("_")        splitdwords.append(splitsname)    return splitdwordsdef search_part_of_speech(wordfrommodul, part):    """    :param wordfrommodul: words that need to be check for part of the speech            part: speech for which you want to test the word    :return:list of matching words    """    names = list(filter(lambda x: len(x)> 0, add_values(wordfrommodul)))    listword = []    for name in names:        if check_part_of_speech(name, part):            listword.append(name)    return listworddef clone_repository(where_from, to_path):    """    :param where_from:URL from where you need to clone    :param to_path:the path to be clone    Clone repository to path    """    return Repo.clone_from(where_from, to_path).working_dirdef create_a_parameter_dictionary(parameters):    """    :param parameters: list if paramiters    :return: dict parameters    creates a dictionary of program parameters    """    dictparameters = {}    for i in parameters:        t =  i.split(",")    index = 0    while index < len(t):        if t[index] != '':            dictparameters['paramiternomber_' + str(index+1)] = t[index]        else:            dictparameters['paramiternomber_' + str(index+1)] = None        index = index + 1    return dictparametersdef extract_most_used_functions(listofwords):    return {word: count for word, count in collections.Counter(listofwords).most_common(200)}def show_the_result_of_counting_words(words):    for word, occurrence in words.items():        print(word, occurrence)def save_in_file(formatfile, mostcommonwords):    """    :param formatfile: format which you need to dave the file    :param mostcommonwords: dict words words and number of uses    """    if len(mostcommonwords) == 0:        return None    if formatfile == "JSON":        with open('json.txt', 'a') as file:            json.dump(mostcommonwords, file,sort_keys = True)    elif formatfile == "CSV":        with open('csv.csv', 'a') as file:            writer = csv.writer(file)            for word, count in mostcommonwords.items():                writer.writerow([word, count])if __name__ == "__main__":    parameters = input("enter the report's positional parameters, separated by commas: ").strip().splitlines()    dictparameters = create_a_parameter_dictionary(parameters)    paths = [os.getcwd()]    if dictparameters["paramiternomber_1"] is not None:        pathclone = os.path.abspath(input("please, input your pass where need clone repository: ").strip())        paths = [clone_repository(dictparameters["paramiternomber_1"],pathclone)]    if dictparameters["paramiternomber_2"] != None:        partofspeech = dictparameters["paramiternomber_2"].strip()    else:        partofspeech = None    if dictparameters["paramiternomber_3"] != None:        codepart = dictparameters["paramiternomber_3"].strip()    names = form_path_python_files(paths)    print('total %s files' % len(names))    trees = form_trees_ast(names)    if codepart == "VARIABLE":        codepart = ast.Name        listwords = serch_variables_names(trees, codepart)    elif codepart == "FUNCTION":        codepart = ast.FunctionDef        listnames = search_functions_in_trees(trees, codepart)        listwords = find_not_special_functions_in_tree(listnames)    else:        raise ValueError("Not the correct paramter, correct -  VARIABLE or FUNCTION")    print('trees generated')    splitednames = split_name_in_part_of_speech(listwords)    partsofspeech = search_part_of_speech(splitednames, partofspeech)    mostcommonwords = extract_most_used_functions(partsofspeech)    print('total %s words, %s unique' % (len(mostcommonwords), len(set(mostcommonwords))))    show_the_result_of_counting_words(mostcommonwords)    if dictparameters["paramiternomber_4"] != None:        save_in_file(dictparameters["paramiternomber_4"].strip(), mostcommonwords)